a) в 14 строке не хватает ключевого слова virtual, чтобы сделать метод getName() виртуальным, без
него при вызове p.getName() будет вызываться Parent::getName() вместо Child::getName().

Ответ автора: Parent::getName() не является виртуальной функцией, поэтому p.getName() не вызовет
 Child::getName().

b) в 25 строке присутствует ключевое слово const, что делает метод Child::getName() совершенно
новым, отличным от родительского виртуального Parent::getName() метода. Несовпадение сигнатур
методов родительского и дочернего классов при переопределении метода.

Ответ автора: Хотя метод Child::getName() является константным, метод Parent::getName() не является
константным, поэтому Child::getName() не считается переопределением и, следовательно, не вызывается.

c) В 31 строке копирующей инициализацией создается объект p класса Parent, вместо создания ссылки на
 объект ch класса Parent, в результате чего происходит обрезка объекта и p.getName() вызывает не
 переопределенный метод Parent::getName()

Ответ автора: Объект ch присваивается объекту p по значению (а не по ссылке), что приводит
 к обрезке объекта ch.

d) Parent имеет ключевое слово final, запрещающее дальнейшее наследование.

Ответ автора: Класс Parent был объявлен как final, поэтому класс Child не может наследовать
 класс Parent. Результат — ошибка компиляции.

e) Child::getName() объявлен как чистый виртуальный/абстрактный метод, в результате чего класс Child
 является абстрактным классом, объекты которого нельзя создавать.

Ответ автора: Child::getName() является абстрактной функцией, хотя имеет тело (записанное отдельно),
 поэтому класс Child является абстрактным, а объекты абстрактного класса создавать нельзя.

f) вроде нет ошибок, ибо в 31 строке происходит неявное приведение к базовому типу, не требующее
dynamic_cast, в 32 строке вызывается метод p->getName() указателем класса Parent, но который
указывает на дочерний объект с виртуальным методом getName(), который переопределен. А удаление
указателя p удаляет и динамически выделенную память для указателя ch, ведь они указывают на один и
тот же адрес в памяти.

Ответ автора: Эта программа выводит верный результат, но имеет другую проблему. В конце функции
 main() мы удаляем p, который является указателем класса Parent, но у нас нет виртуального
 деструктора в классе Parent. Следовательно, удаляется только часть Parent объекта класса ch,
 а часть Child объекта ch остается в виде утечки памяти.